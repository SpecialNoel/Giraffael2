# client.py

'''
To run this script: python3 client.py
Note: must be executed when the server is alive.

Note: 'client' is essentially only a socket in client.py
'''


import socket
from recv_from_server import recv_msg_from_server
from send_to_server import (get_and_send_user_input_to_server,
                            send_decision_on_room_to_server,
                            send_room_code_to_server,
                            send_username_to_server)
from check_server_capacity import check_server_capacity
from threading import Thread, Event


class Client:
    def __init__(self):
        self.SERVER_IP = '127.0.0.1' # depending on server ip
        self.SERVER_PORT = 5001
        
        self.client = self.init_client_socket() # client socket
        
        self.shutdownEvent = Event() # threading.Event()
        self.ruleAboutRoomCodeSent = False
        
        self.TYPE_PREFIX_SIZE = 1
        self.MSG_CONTENT_SIZE = 1024
        self.CHUNK_SIZE = self.TYPE_PREFIX_SIZE + self.MSG_CONTENT_SIZE


    def init_client_socket(self):
        try: 
            # TCP connection
            self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # Connect to the server socket with [IP, Port number] combination
            self.client.connect((self.SERVER_IP, self.SERVER_PORT)) 
            return self.client
        except ConnectionRefusedError:
            print('Connection refused. Server is not on yet.')
            return None

        
    def run_client(self):
        # Prevent connection if client socket is not initialized correctly
        if self.client == None:
            exit()
        # Prevent connection if server reached max client capacity
        if not check_server_capacity(self.client, self.MSG_CONTENT_SIZE):
            print('Connection failed: server reached max client capacity.')
            exit()
            
        # Try sending client decision on room to server
        # If msg is 'C', response will be a room code generated by server
        # If msg is 'E', response will be:
        #   1. server generated room code, if received <c> from client
        #   2. 'VALID_ROOM_CODE' sent by server, if the room code is valid
        #   3. an error message sent by server, otherwise
        # Otherwise,     response will be an error message sent by server
        print('Input <C> to Create a new room, OR')
        print('Input <E> to Enter an existing room.\n')
        msg, response = send_decision_on_room_to_server(self.client, 
                                                        self.CHUNK_SIZE)
        while msg.upper() != 'C':
            print(f'msg: {msg}, response from server: {response}')
            if msg.upper() == 'E':
                msg, response = send_room_code_to_server(self.client, 
                                                         self.CHUNK_SIZE)
                print(f'msg: {msg}, response from server: {response}')
                if msg.upper() == 'C':
                    break
                if response == 'VALID_ROOM_CODE':
                    response = msg
                    break
            msg, response = send_decision_on_room_to_server(self.client, 
                                                            self.CHUNK_SIZE)
        print(f'In Room: [{response}].\n')
        
        # Try sending client username to server
        msg, response = send_username_to_server(self.client, 
                                                self.CHUNK_SIZE)
        while response != 'VALID_USERNAME':
            print(f'msg: {msg}, response from server: {response}')
            msg, response = send_username_to_server(self.client, 
                                                    self.CHUNK_SIZE)
            
        # Use thread t1 to receive message from server
        t1 = Thread(target=recv_msg_from_server, args=(self.client, 
                                                       self.shutdownEvent,
                                                       self.CHUNK_SIZE))
        t1.daemon = True
        t1.start()

        # Use thread t2 to send message to server
        t2 = Thread(target=get_and_send_user_input_to_server, args=(self.client,
                                                                    self.shutdownEvent,
                                                                    self.MSG_CONTENT_SIZE))
        t2.daemon = True
        t2.start()
    
        # Wait until t1 and t2 converges
        t1.join()
        t2.join()
        print('All threads joined.')
        print('Client socket closed.')
        exit()
        

if __name__ == '__main__':
    client = Client()
    client.run_client()
    