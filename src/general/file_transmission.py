# file_transmission.py

import json
import os
from pathlib import Path

from general.message import add_prefix, rstrip_message

'''
Functions here are used by clients or server to transfer 
  different kinds of files (.jpg, .pdf, .txt, .csv, etc.).
'''

CHUNK_SIZE = 1025
MAX_FILE_SIZE = 104857600 # in bytes; which is equivalent to 100MB
EXT_LIST = ['.txt',  '.md',   '.json', '.xml', '.csv',
           '.docx', '.xlsx', '.pdf',  '.py',  '.html',
           '.css',  '.cpp',  '.java', '.tar.gz',
           '.png',  '.jpg',  '.gif',  '.mp3', '.mp4', '.db']

def display_rule():
    print('\nInput message to send to this chatroom,',
          '\nInput [send] to upload a file to this room,',
          '\nInput [recv] to download a file from this room,',
          '\nInput [msg history] to display all message history in this room,',
          '\nInput [file history] to display all files stored in this room,',
          '\nInput [clear msg history] to delete all message history in this room,'
          '\nInput [clear file history] to delete all files stored in this room,',
          '\nInput [clear all history] to delete all history of this room.',
          '\nInput [ai suggestion] to get message suggestions generated by OpenAI model.',
          '\nPress [Enter/Return] key to disconnect.\n')
    return

def find_file_in_directory(filename, target_dir, start_dir='.'):
    '''
    Used by server to check if it has the file in target_dir,
      for which client wanted to download to their local machine
    '''
    for root, dirs, files in os.walk(start_dir):
        if os.path.basename(root) == target_dir and filename in files:
            return os.path.join(root, filename)
    return None

def check_if_directory_exists(directory):
    if not directory:
        directory = '.'
    if not os.path.exists(directory):
        print(f'Invalid directory: [{directory}] does not exist.')
        return False
    if not os.access(directory, os.W_OK):
        print(f'Invalid directory: [{directory}] is not writable.')
        return False
    print(f'Directory [{directory}] exists.')
    return True

def check_if_filename_is_valid(filename):
    try:
        # Attempt to create a Path object
        Path(filename)
        return True
    except Exception as e:
        print(f'Invalid filename: [{e}].')
        return False
    
def check_if_filepath_exists(filepath):
    print(f'Filepath [{filepath}] exists: [{os.path.isfile(filepath)}].')
    return os.path.isfile(filepath)
    
def check_if_file_exists(filepath):
    '''
    Used by the sender to check if the file exists or not.

    @param filepath: the filepath of the file
    @return: True if the filepath is a file; False otherwise 
    '''
    try:
        if not check_if_directory_exists(filepath):
            return False
        if not os.path.basename(filepath):
            print('Invalid filepath: filename is missing.')
            return False
        return check_if_filepath_exists(filepath)
    except Exception as e:
        print(f'Error validating filepath: {e}')
        return check_if_filepath_exists(filepath)

def get_valid_filepath(filepath):    
    while not check_if_file_exists(filepath):
        print('\nType in filepath of the file you want to send:')
        print('OR, type <exit> to stop sending file.\n')
        filepath = rstrip_message(input())
        # Client does not want to send the file anymore
        if filepath.lower() == 'exit':
            return None        
    return filepath

def get_extension_from_filename(filename):
    # Returns the extension of a file, including dot.
    # Example: .txt, .pdf, .png, etc..
    return os.path.splitext(filename)[1]

def check_if_filesize_is_valid(filesize, maxFileSize):
    def check_valid_filesize(filesize, maxFileSize):
        return filesize <= maxFileSize
    
    # If filesize is exceeded MAX_FILE_SIZE, stop sending/receiving the file
    if not check_valid_filesize(filesize, maxFileSize):
        print(f'Invalid filesize: File has a size of [{filesize}],',
              f'which is larger than Maximum File Size: [{maxFileSize}].')
        return False # filesize > MAX_FILE_SIZE
    return True      # filesize <= MAX_FILE_SIZE

def check_if_filename_has_valid_extension(extension, extList):
    def check_valid_extension(extension, extList):
        return extension in extList
    
    # If extension is not in extList, stop sending/receiving the file
    if not check_valid_extension(extension, extList):
        print(f'Invalid file extension: File ends with [{extension}].',
              f'Valid extensions: {extList}.')
        return False # extension not in extList
    return True      # extension in extList

def create_metadata(filepath):
    '''
    Used by the sender to create the associate metadata of the file.
    The metadata will be sent to the recipient before receiving 
    the original file.

    @param filepath: the filepath of the file
    @return: filename, filesize
    '''
    filename = os.path.basename(filepath)
    filesize = os.path.getsize(filepath)
    print(f'Filename: [{filename}], filesize: [{filesize}].\n')
    return filename, filesize

def send_metadata(socket, filename, filesize):
    metadata = {
        'filename': filename,
        'filesize': filesize
    }
    metadata_json = json.dumps(metadata)
    metadata_bytes = metadata_json.encode()
    socket.send(add_prefix(metadata_bytes, 2))
    return

def send_directory_and_filename(socket, directory, filename):
    dirAndName = {
        'directory': directory,
        'filename': filename
    }
    dirAndName_json = json.dumps(dirAndName)
    dirAndName_bytes = dirAndName_json.encode()
    socket.send(add_prefix(dirAndName_bytes, 3))
    return

def get_directory_and_filename(dirAndNameEncoded):
    dirAndName_json = dirAndNameEncoded.decode()
    dirAndName = json.loads(dirAndName_json)
    directory = dirAndName['directory']
    filename = dirAndName['filename']
    print(f'Directory: [{directory}], filename: [{filename}].')
    return directory, filename

def check_metadata_format(metadata):
    if len(metadata) == 2 and metadata['filename'] and metadata['filesize']:
        print('Metadata format is valid.')
        return True
    print('Invalid metadata format.')
    return False

def split_metadata(metadataBytes):
    metadata_json = metadataBytes.decode()
    metadata = json.loads(metadata_json)
    filename = metadata['filename']
    filesize = int(metadata['filesize'])
    print(f'Filename: [{filename}], filesize: [{filesize}].')
    return filename, filesize

def get_filepath_without_duplication(filepath):
    counter = 1
    filenameWithExt = os.path.basename(filepath)
    filename, extension = os.path.splitext(filenameWithExt)
    base, extension = os.path.splitext(filepath)
    directory = os.path.dirname(filepath)
    while check_if_filepath_exists(filepath):
        # Filepath exists -> filename is duplicated on recipient's end
        # Need to append a counter to the end of filename, 
        #   but before extension, to solve duplication
        newFilename = f'{filename}_{counter}{extension}'
        filepath = os.path.join(directory, newFilename)
        print(f'New filepath: {filepath}')
        counter += 1
    return filepath

def send_file(filepath, filename, socket, chunk_size, recipient):
    '''
    Used by the sender to send the file to the recipient.
    
    @param filepath: the filepath of the file
    @param socket: the socket used to send the file; the sender socket
    @param chunk_size: number of bytes to send to the recipient each time
    @param recipient: either 'server' or address of a client; 
                      indicates the receiver side
    @return: None
    '''
    try:
        with open(filepath, 'rb') as file:
            while chunk := file.read(chunk_size):
                socket.send(chunk)
        print(f'Successfully sent file [{filename}] to [{recipient}].')
    except FileNotFoundError:
        print(f'File with path [{filepath}] not found.')
    except Exception as e:
        print(f'Error occurred in send_file(): [{e}].')
    return

def recv_file(filename, filepath, filesize, socket, chunkSize, sender):
    '''
    Used by the recipient to receive the file from the sender.
    Received content will be stored in the 'received_files' folder
      with the same filename as the received filename.
    
    @param filename: the string name of the file
    @param filesize: the size of the file
    @param socket: the socket used to receive the file; the receiver socket
    @param chunkSize: number of bytes to receive from the sender each time
    @param sender: either 'server' or address of a client; 
                   indicates the sender side
    @return: None
    '''
    try:
        filepath = os.path.join(filepath, filename)
        filepath = get_filepath_without_duplication(filepath)
        with open(filepath, 'wb') as file:
            received_len = 0
            while received_len < filesize:
                data = socket.recv(chunkSize)
                if not data:
                    break
                file.write(data)
                received_len += len(data)
        print(f'Successfully received file [{filename}] from [{sender}].\n')
        print(f'The file is Stored in filepath: [{filepath}].')
    except Exception as e: 
        print(f'Error occurred in recv_file(): [{e}].')
    return
