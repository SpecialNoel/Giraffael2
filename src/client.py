# client.py

# To run this script: python3 client.py
# Note: must be executed when the server is alive.


# Note:
# 'client' is essentially only a socket in client.py

import socket
from threading import Thread, Event


def init_client_socket(serverIP, serverPort):
    try: 
        # TCP connection
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Connect to the server socket with the [IP, Port number] combination
        client.connect((serverIP, serverPort)) 
        return client
    except ConnectionRefusedError:
        print('Connection refused. Server is not on yet.')
        return None


def recv_msg_from_channel(client, shutdownEvent):
    # Receive message from other clients in the channel
    while not shutdownEvent.is_set():
        try:
            msg = client.recv(1024)
            # Received a message of string 0 (only possible from server)
            # This means that the server wants to close the connection
            #   established by this client b/c of max num of clients reached
            if not msg:
                print('Server has closed the connection.')
                shutdownEvent.set()
                break
            print(msg.decode() + '\n')
        except Exception as e:
            print(f'Error [{e}] occured when receiving message.')
            break
    client.close()
    print('Client receiver thread stopped.')
    return

    
def get_and_send_user_input_msg(client, shutdownEvent):
    ruleSent = False

    while not shutdownEvent.is_set():
        if not ruleSent: 
            ruleSent = True
            print('\nType a message to send to the channel, ',
                  'or\nPress [Enter/Return] key to disconnect.\n')
            
        msg = input()
        if msg == '':
            print('Disconnected from the channel.\n')
            shutdownEvent.set()
            client.close()
            break
        else:
            client.send(msg.encode())
    print('Client sender thread stopped.')
    return

    
def send_username_to_server(client):
    print('Type in your username: ')
    msg = input()
    client.send(msg.encode())
    response = client.recv(1024)
    return response.decode()
    

def send_decision_on_room_to_server(client):
    print('Type in a single letter <C> to Create a new room, OR')
    print('Type in a single letter <E> to Enter an existing room.')
    msg = input()
    client.send(msg.encode())
    response = client.recv(1024)
    return msg, response.decode()


def send_room_code_to_server(client):
    print('Type in the room code to enter an existing room.')
    msg = input()
    client.send(msg.encode())
    response = client.recv(1024)
    return msg, response.decode()

    
def check_if_server_reached_max_client_capacity(client):
    msg = client.recv(1024)
    print(f'Init msg from server: {msg.decode()}.')
    
    if msg.decode() == '-1':
        print('Connection refused by server: max client count reached.')
    else:
        print('Connected to server successfully!')
    
    return msg.decode() != '-1'


def is_connection_alive(client):
    try:
        client.send(b'')
        return True
    except (BrokenPipeError, 
            ConnectionResetError, 
            ConnectionAbortedError) as e:
        print(f'Error: {e}. ',
              f'Connection with server is no longer alive.')
        return False


if __name__ == '__main__':
    SERVER_HOST = '127.0.0.1'
    SERVER_PORT = 5001
    
    client = init_client_socket(SERVER_HOST, SERVER_PORT)
    if client == None:
        exit()
    
    if not check_if_server_reached_max_client_capacity(client):
        exit()
            
    # If msg is 'C', responseOnRoomCode will be a room code generated by server
    # If msg is 'E', responseOnRoomCode will be:
    #   1. 'VALID_ROOM_CODE' sent by server, if room code from client is valid
    #   2. an error message sent by server, otherwise
    # Otherwise,     responseOnRoomCode will be an error message sent by server
    msg, responseOnRoomCode = send_decision_on_room_to_server(client)
    while msg.upper() != 'C':
        print(f'msg: {msg}, response from server: {responseOnRoomCode}')
        if msg.upper() == 'E':
            msg, responseOnRoomCode = send_room_code_to_server(client)
            if msg.upper() == 'C':
                break
            if responseOnRoomCode == 'VALID_ROOM_CODE':
                responseOnRoomCode = msg
                break
        msg, responseOnRoomCode = send_decision_on_room_to_server(client)
            
    responseOnUsername = send_username_to_server(client)
    while responseOnUsername != 'VALID_USERNAME':
        print(responseOnUsername)
        responseOnUsername = send_username_to_server(client)
        
    shutdownEvent = Event() # threading.Event()

    # Use thread t1 to receive message
    t1 = Thread(target=recv_msg_from_channel, args=(client,shutdownEvent,))
    t1.daemon = True
    t1.start()

    # Use thread t2 to send message
    t2 = Thread(target=get_and_send_user_input_msg, 
                args=(client,shutdownEvent,))
    t2.daemon = True
    t2.start()
    
    t1.join()
    t2.join()

    #client.close()
    print('Client socket closed.')